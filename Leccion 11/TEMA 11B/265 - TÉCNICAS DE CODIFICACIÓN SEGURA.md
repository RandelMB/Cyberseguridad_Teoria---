
Las consideraciones de seguridad para las nuevas tecnologías de programación deben comprenderse y probarse bien antes de su implementación. Uno de los desafíos del desarrollo de aplicaciones es que la presión para lanzar una solución, por lo general, supera cualquier requisito para garantizar que la aplicación sea segura. Un proceso de diseño de software heredado podría centrarse en gran medida en elementos muy visibles, como la funcionalidad, el rendimiento y el costo. Las prácticas de desarrollo modernas utilizan un ciclo de vida de desarrollo de seguridad que se ejecuta en paralelo o integrado con el enfoque de la funcionalidad y la usabilidad del software. Algunos ejemplos son SDL de Microsoft (microsoft.com/en-us/securityengineering/sdl), y OWASP Software Assurance Maturity Model (owasp.org/www-project-samm) y Security Knowledge Framework (https://owasp.org/projects/spotlight/historical/2021.02.03/). OWASP también recopila descripciones de vulnerabilidades, exploits y técnicas de mitigación específicas, como el Top 10 de OWASP (owasp.org/www-project-top-ten).

Validación de entradas
La input validation (validación de entradas) es una técnica de protección primordial que se utiliza en software y desarrollo web que aborda el problema de las entradas no confiables. La entrada no confiable describe cómo un atacante puede proporcionar datos especialmente diseñados a una aplicación para manipular su comportamiento. Los ataques de inyección explotan los mecanismos de entrada en los que se basan las aplicaciones para ejecutar comandos y scripts maliciosos a fin de acceder a datos confidenciales, controlar el funcionamiento de la aplicación, obtener acceso a sistemas back-end protegidos e interrumpir las operaciones.

OWASP ofrece una excelente descripción general de la validación de entradas en https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html. 

Sin una validación de entradas efectiva, las aplicaciones son vulnerables a muchas clases diferentes de ataques de inyección, tales como inyección de SQL, inyección de código, secuencias de comandos entre sitios (XSS) y muchos otros.

![[Pasted image 20250403074449.png]]

Cookies seguras
Las cookies son pequeños fragmentos de datos almacenados en una computadora por un navegador web mientras se accede a un sitio web. Mantienen los estados de sesión, recuerdan las preferencias del usuario y hacen un seguimiento del comportamiento del usuario y otras configuraciones. Las cookies pueden explotarse si no se protegen de manera adecuada, lo que lleva a ataques como el secuestro de sesiones o las secuencias de comandos entre sitios. 

Para implementar cookies seguras, los desarrolladores deben seguir ciertos principios bien documentados, como el uso del atributo 'Secure' para todas las cookies a fin de garantizar que solo se envíen a través de conexiones HTTPS y estén protegidas contra la interceptación mediante espionaje, el uso del atributo 'HttpOnly' para evitar que los scripts del lado del cliente accedan a las cookies y para la protección contra ataques de secuencias de comandos entre sitios, y el uso del atributo 'SameSite' para limitar cuándo se envían cookies para mitigar los ataques de falsificación de solicitudes entre sitios. Además, las cookies deben tener límites de tiempo de caducidad para restringir su vida útil.

Las técnicas de cookies seguras son fundamentales para mitigar varios ataques a aplicaciones basadas en web, en particular los centrados en el acceso no autorizado o la manipulación de cookies de sesión. Los desarrolladores pueden defenderse de los ataques que se dirigen a ellos a través del uso de atributos específicos dentro de las cookies.

Análisis de código estático
El análisis de código estático es una práctica esencial de desarrollo de software. Implica examinar el código fuente para identificar posibles vulnerabilidades, errores y prácticas de codificación que no cumplen con las normas antes de finalizar el programa. Al examinar el código en un estado 'estático', los desarrolladores pueden detectar y rectificar problemas al principio del ciclo de vida de desarrollo. Esto lo convierte en un enfoque proactivo para crear software seguro, confiable y de alta calidad.

Los enfoques de seguridad de las aplicaciones se centran en los ciclos de vida de desarrollo e implementación de software, con un gran énfasis en las prácticas de codificación segura que animan a los desarrolladores a escribir código que evite vulnerabilidades comunes como la inyección de SQL y las secuencias de comandos entre sitios. Las prácticas de seguridad de las aplicaciones también exigen pruebas de seguridad de aplicaciones estáticas (SAST) y dinámicas. Las prácticas de codificación diseñadas para admitir parches y actualizaciones de manera periódica son fundamentales para respaldar la resolución rápida de vulnerabilidades recién descubiertas.

El análisis de código estático es compatible con la codificación segura y se realiza mediante herramientas especializadas, a menudo integradas en suites de desarrollo de software. Estas herramientas automatizan las comprobaciones del código en función de reglas predeterminadas y marcan posibles problemas para que los desarrolladores puedan revisarlos y abordarlos. Algunas herramientas de análisis estático de uso común incluyen SonarQube (https://www.sonarsource.com/products/sonarqube/), Coverity (https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html) y Fortify (https://www.microfocus.com/en-us/cyberres/application-security), pero existen muchas más.

El análisis de código estático en el desarrollo de software es fundamental porque permite la detección temprana de errores y vulnerabilidades de seguridad, y ayuda a prevenir fallas potencialmente catastróficas en el producto final. También mejora la calidad y la capacidad de mantenimiento del código al hacer cumplir los estándares de codificación y las mejores prácticas. Además, el análisis de código estático ayuda a educar a los desarrolladores sobre los errores de codificación comunes y los riesgos de seguridad, y esto ayuda a promover prácticas de desarrollo conscientes de la seguridad. 

Firma de código
Las prácticas de code signing (firma de código) utilizan firmas digitales para verificar la integridad y autenticidad del código de software. La code signing (firma de código) tiene un doble propósito: garantizar que el software no haya sido manipulado desde la firma y confirmar la identidad del editor de software.

Cuando el software está firmado de manera digital, el firmante utiliza una clave privada para cifrar un hash o resumen del código. Este hash cifrado y la identidad del firmante forman la firma digital. La code signing (firma de código) requiere el uso de un certificado emitido por una autoridad certificadora (CA) de confianza. El certificado contiene información sobre la identidad del firmante y es fundamental para verificar la firma digital. Si el certificado es válido y es emitido por una CA de confianza, la identidad del editor de software se puede verificar con toda seguridad. La code signing (firma de código) ayuda a los analistas y administradores a bloquear el software que no es de confianza y también ayuda a proteger a los editores de software al proporcionar un mecanismo para validar la autenticidad de su código. En general, la code signing (firma de código) ayuda a generar confianza en el proceso de distribución de software. 

Si bien la code signing (firma de código) proporciona seguridad sobre el origen del código y verifica la integridad del código, no garantiza inherentemente la seguridad del código en sí. La code signing (firma de código) certifica la fuente y la integridad del código, pero no evalúa la calidad o la seguridad del código. El código firmado aún podría contener errores, vulnerabilidades o código malicioso insertado por el autor original. La firma garantiza que el software es del desarrollador esperado y está en el estado que el desarrollador pretendía. Si bien la code signing (firma de código) agrega confianza y autenticidad a la distribución de software, no se debe confiar en ella para garantizar un código seguro o libre de errores.


Revisión de la firma digital contenida en el instalador de la aplicación Bitwarden Password Management.